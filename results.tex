\chapter{Results}\label{C:results} 
\section{Java}
The intent in analysing the Qualitas Corpus of Java code is to determine the extent to which developers are making use of Java's inbuilt language features and what developers are doing to work around these language features. Specifically, a Java developers' usage of class inheritance will represent them conforming to the classical inheritance model encouraged by the Java language. In contrast, instances of code which model call forwarding or call delegation will represent cases where the developer could have expressed themselves more concisely through other object inheritance models where delegation and forwarding are supported natively. The following patterns are used to identify instances of each model of reuse within the Java projects.

\begin{center}
	\captionof{table}{Java Patterns}
	\label{JavaPatterns}
	\begin{tabular}{|p{5cm}|p{9cm}|}
		\hline
		
		\multicolumn{2}{|c|}{Java}                                                                   
		
		\\ \hline
		
		Forwarding                     & \java{anything name (anything)\{} \newline  \hphantom{----}\java{return identifier{[}.identifier{]}*.name(anything);} \newline
		\java{\}}  \\ 
		\hline
		
		Call Delegation                     & \java{anything name (anything) \{} \newline   \hphantom{----}\java{return identifier{[}.identifier{]}*.name(this);} \newline \java{\}}		
		\\ \hline
		
		Constructor Delegation & \java{anything anything = new anything ( this )}
		
		\\ \hline
		
		Inheritance                    & \java{class extends anything}

		\\ \hline
	\end{tabular}\newline\newline
\end{center}

The presence of two patterns representing delegation is because there are two main ways this behaviour can be represented in Java. The first, call delegation, is where an object passes itself as a parameter to some delegatee and has that delegatee perform some action on its behalf. The second, constructor delegation, is where a delegatee is constructed specifically for the instance of the delegator. This delegatee can then act on that constructor argument when its other methods are called.
\newline\newline\newline

The frequency of occurrence of each of the above patterns was calculated and aggregated to produce corpus level analysis which can be found in the following table:

\begin{center}
	\captionof{table}{Java Analysis Results}
	\begin{tabular}{|l|l|l|l|}
		\hline
		& Count  & \% of classes & \% of extended classes \\ \hline
		Total classes                                                                                   & 116427 &               &                        \\ \hline
		Classes extend another class                                                                    & 71203  & 61.16\%       &                        \\ \hline
		Classes are extended by another class                                                           & 20751  & 17.82\%       &                        \\ \hline
		Classes with forwarding                                                                         & 7087   & 6.09\%        &                        \\ \hline
		\begin{tabular}[c]{@{}l@{}}Classes with forwarding\\ that extend another class\end{tabular}     & 3381   & 2.90\%        &                        \\ \hline
		Classes with downcalls in constructors                                                          & 16101  & 13.83\%       &                        \\ \hline
		Classes storing this in constructors                                                            & 2392   & 2.05\%        &                        \\ \hline
		\begin{tabular}[c]{@{}l@{}}Classes with downcalls or\\ storing this in constructor\end{tabular} & 17099  & 14.69\%       &                        \\ \hline
		\begin{tabular}[c]{@{}l@{}}Extended classes with\\ downcalls in constructors\end{tabular}       & 1545   & 1.33\%        & 7.45\%                 \\ \hline
		\begin{tabular}[c]{@{}l@{}}Extended classes storing\\ this in constructors\end{tabular}         & 178    & 0.15\%        & 0.86\%                 \\ \hline
		Classes with delegation                                                                         & 5183   & 4.45\%        &                        \\ \hline
	\end{tabular}
\end{center}

\subsection{Detecting Delegation}
Due to the imprecise definition of what it means to model delegation in Java, it is expected that some of the results which are returned in the search for these delegation patterns will be false positives. Upon manual inspection of some of the corpus files, some of the patterns which meet the criteria outlined in \ref{JavaPatterns} would not generally be considered to exhibit the true behaviour delegation. An example of this is object self registration where and object registers itself with some other object which will make use of the registered object in some way. To continue the example of the \java{Square} class, an instance of \java{Square} could, at construction time,  register itself to a \java{Canvas} so that the \java{Canvas} can call back to the \java{Square} to request details necessary for drawing. The \java{Square} class would have a constructor parameter which is a reference to the \java{Canvas} object:
\begin{lstlisting}
public Square(Canvas canvas){
	canvas.register(this);
}
\end{lstlisting}
And a \java{Square} could be added to the \java{Canvas} as follows:
\begin{lstlisting}
void addSquare(){
	Square s = new Square(this);
}
\end{lstlisting}
This matches the pattern of Constructor Delegation in \ref{JavaPatterns} but , in reality, is modelling a different intent. Because of this, the statistics gathered for delegation should be treated as an upper bound on the actual frequency of occurrence of the behaviour.
\newline

\section{C\#}
C\# is a useful language to investigate because it requires use of the \cs{virtual} keyword to enable overriding of any given method, otherwise defaulting to static method dispatch. This is interesting because it forces the developer to make their intent to override a method explicit, in contrast to Java where virtual dispatch is the default and occurs when the developer has simply omitted the \java{final} modifier. This makes it much more clear whether there could potentially be construction issues if we had a different way of initialising objects in place of Uniform Identity. When the \cs{virtual} keyword is required, the only method calls which could miss their intended target when used in a constructor are those which are explicitly labelled as \cs{virtual} dispatch calls.

\begin{center}
	\centering
	\captionof{table}{C\# Analysis Results}
	\label{CsResults}
	\begin{tabular}{|l|l|l|l|}
		\hline
		& Total  & \% of methods & \% of classes \\ \hline
		Projects                                                                                                       & 25     &                    &                    \\ \hline
		Files                                                                                                          & 31615  &                    &                    \\ \hline
		Classes                                                                                                        & 71162  &                    &                    \\ \hline
		Extending Classes                                                                                              & 25654  &                    & 36.05\%            \\ \hline
		Methods                                                                                                        & 232282 &                    &                    \\ \hline
		Virtual Methods                                                                                                & 11194  & 4.82\%             &                    \\ \hline
		Override Methods                                                                                               & 28815  & 12.41\%            &                    \\ \hline
		\begin{tabular}[c]{@{}l@{}}Classes with calls to local\\ methods in constructors\end{tabular}                  & 1731   &                    & 2.43\%             \\ \hline
		\begin{tabular}[c]{@{}l@{}}Classes with calls to local\\ virtual methods in constructors\end{tabular}          & 117    &                    & 0.16\%             \\ \hline
		\begin{tabular}[c]{@{}l@{}}Classes with calls to local\\ override methods in constructors\end{tabular}         & 56     &                    & 0.08\%             \\ \hline
		\begin{tabular}[c]{@{}l@{}}Classes with calls to local\\ abstract methods in constructors\end{tabular}         & 17     &                    & 0.02\%             \\ \hline
		\begin{tabular}[c]{@{}l@{}}Classes with calls to methods\\ that couldn't be found in constructors\end{tabular} & 479    &                    & 0.67\%             \\ \hline
	\end{tabular}\newline\newline
\end{center}

The first notable difference between the C\# results and those for Java is the drastic reduction in the number of calls to local methods from constructors, 2.43\% for C\# compared with 13.18\% for Java.
\newline

The valuable information gained from the C\# analysis which was not able to be retrieved in the Java analysis is the breakdown of classes with local method calls based on whether those method calls are static or virtual dispatch. The analysis showed that only 0.26\% of all classes contained a call to a method where a virtual, abstract or override declaration was found for that method. These are the method calls which would potentially miss their intended target in a construction environment different from Uniform Identity so the rare occurrence of these cases is valuable information. Across the corpus of 71,162 total classes, only 190 would need to be modified to mitigate potential construction issues under a new object initialisation environment.
\newline

\subsection{Methods that couldn't be found}
As with Java, there were some limitations to the accuracy of the analysis performed due to some of the limitations of pure source code analysis. The limits are most obvious in the final row of \ref{CsResults} where we find that 0.67\% of classes contained a local method call where the destination of that call could not be found. This can occur when the analysis comes across a couple of cases.
\begin{itemize}
	\item A constructor contains a non-local method call which is indistinguishable from a local method call without more information. An example of this is the use of C\%'s \cs{using static} syntax which imports the static functions from another namespace and a allows those functions to be called in a way that looks identical to a local method call. The \cs{using static} pattern allows this code:
	\begin{lstlisting}[language=cs]
	using System.Console;
	class Program : SuperProgram
	{ 
		static void Main() 
		{ 
			Console.WriteLine("Hello world!"); 
		} 
	}
	\end{lstlisting}
	to be changed to this:
	\begin{lstlisting}[language=cs]
	using static System.Console;
	class Program : SuperProgram
	{ 
		static void Main() 
		{ 
			WriteLine("Hello world!"); 
		} 
	}
	\end{lstlisting}
	And without information about the contents of \cs{System.Console}, it is not possible to determine that \cs{WriteLine()} is a function defined in that namespace.
	\item A class extends a class in a pre-compiled library. If a call is made from a constructor to a local virtual or abstract method defined in a pre-compiled superclass then, unless that method has been overridden by the class being analysed, there is no way to know that the method was virtual or abstract.
\end{itemize}

\section{JavaScript}
In JavaScript, there are many ways developers make use of classical inheritance patterns despite the lack of native support in the language. This is largely a result of the numerous libraries which offer their own implementation of classical inheritance behaviour. Some examples of these patterns can be found in the following table:
\begin{center}
	\captionof{table}{JavaScript Patterns}
	\begin{tabular}{|p{5cm}|p{9cm}|}
		\hline
		\multicolumn{2}{|c|}{JavaScript}                                                                                                                                                                  \\ \hline
		Inheritance 1                  & \code{var a = function( b )\{    c.call ( this , d );\}}                                                                                      \\ \hline
		Inheritance 2                  & \code{function Bar( x , y )\{    Foo.call ( this , x ) ;\}}                                                                                 \\ \hline
		Inheritance 3                  & \code{Foo.prototype = object.create ( Bar.prototype )}                                                                                      \\ \hline
		Inheritance 4 - Node.js        & \code{var className = defineClass(...)}                                                                                                           \\ \hline
		Inheritance 5 - Node.js        & \code{ util.inherits(...)}                                                                                                                         \\ \hline
	\end{tabular}\newline\newline
\end{center}

The JavaScript analysis in this study makes extensive use of the prior work in developing the JSClassFinder application~\cite{JSClassFinder}. The aim here is to find the cases where JavaScript developers are choosing not to use the native delegation support of the language and are instead modelling their programs with classical inheritance structures. The important factor here is the Class Usage Ratio (CUR) of a JavaScript project as defined in \textit{Does JavaScript Software Embrace Classes?~\cite{JSClassFinder}}. Across a corpus of 50 JavaScript projects, the JSClassFinder returns interesting results about the prevalence of class usage in the language.
\begin{enumerate}
	\item The median CUR across the corpus was 0.15
	\item The upper quartile CUR across the corpus was 0.36
	\item The lower quartile CUR across the corpus was 0.005, which was heavily impacted by 13 systems which had a CUR of zero
\end{enumerate}
\section{Lua}
Table \ref{LuaResults} shows a variety of patterns often representative of class usage and the percentage of files in the corpus which exhibit one or more of those patterns.\newline

Often functions called class() will be created to encapsulate the \java{setmetatable()} logic which is used to create classes. It is also common to declare functions with the name "new" for use as constructors.

\begin{center}
	\captionof{table}{Lua Analysis Results}
	\label{LuaResults}
	\begin{tabular}{|l|l|l|l|}
		\hline
		Pattern                 & Test               & Result & Percentage \\ \hline
		= setmetatable()        &                    &        &            \\ \hline
		& Total matches      & 135    &            \\ \hline
		& Files with matches & 74     & 2.67\%     \\ \hline
		class(                  &                    &        &            \\ \hline
		& Total matches      & 487    &            \\ \hline
		& Files with matches & 380    & 13.69\%    \\ \hline
		function something.new( &                    &        &            \\ \hline
		& Total matches      & 31     &            \\ \hline
		& Files with matches & 30     & 1.08\%     \\ \hline
		Union of all three      &                    &        &            \\ \hline
		& Total matches      & 653    &            \\ \hline
		& Files with matches & 473    & 17.04\%    \\ \hline
	\end{tabular}
\end{center}{










\iffalse
\subsection{Results from GREP}
\begin{center}
	%\captionof{table}{C\# Analysis Results}
	\label{CsResults}
	\begin{tabular}{|l|l|l|l|}
		\hline
		& Count   & Percent of files & Percent of methods \\ \hline
		Total projects                       & 25      &                  &                    \\ \hline
		Total C\# files                      & 73094   &                  &                    \\ \hline
		Total methods                        & 1415919 &                  &                    \\ \hline
		Files with methods                   & 67480   & 92.32\%          &                    \\ \hline
		Average methods per file             & 19.37   &                  &                    \\ \hline
		&         &                  &                    \\ \hline
		Total override methods               & 85347   &                  & 6.03\%             \\ \hline
		Files with override methods          & 18437   & 25.22\%          &                    \\ \hline
		Average override methods per file    & 1.17    &                  &                    \\ \hline
		&         &                  &                    \\ \hline
		Total virtual methods                & 27668   &                  & 1.95\%             \\ \hline
		Files with virtual methods           & 4553    & 6.23\%           &                    \\ \hline
		Average virtual methods per file     & 0.38    &                  &                    \\ \hline
		&         &                  &                    \\ \hline
		Total classes                        & 159680  &                  &                    \\ \hline
		Files with classes                   & 59488   & 81.39\%          &                    \\ \hline
		Average classes per file             & 2.18    &                  &                    \\ \hline
		&         &                  &                    \\ \hline
		Classes that extend                  & 50442   &                  &                    \\ \hline
		Files with classes that extend       & 30424   & 41.62\%          &                    \\ \hline
		Average classes that extend per file & 0.69    &                  &                    \\ \hline
		Percent of classes that extend       & 31.59\% &                  &                    \\ \hline
	\end{tabular}
\end{center}
Here, we find that just 1.95\% of all method declarations contain the \cs{virtual} keyword.
\fi