\chapter{Code Patterns}\label{C:bg}
To determine how developers are using delegation and inheritance, the first stage is to define a clear way of identifying the behaviour each pattern. This is achieved by defining code patterns which, when found in a project, indicate the use of delegation or inheritance. This chapter outlines the patterns which are representative of forwarding, delegation and uniform identity.

\section{Forwarding}
Under a forwarding model of object inheritance, calls to \java{this.f(...)} are passed to some \java{other.f(...)}, transferring any necessary information as call parameters.
\newline

In the following example, a \java{Square} object is forwarding responsibility for its area calculation to the \java{SquareAreaCalculator}. The \java{SquareAreaCalculator} could be shared by many \java{Square} objects as it holds no state and therefore does not rely on being instantiated as an instance specific and isolated to any given \java{Square}.

\begin{lstlisting}
class Square{
	int x, y, wd;
	SquareAreaCalculator areaCalculator = new SquareAreaCalculator();

	int area(){return areaCalculator.calculate(wd);}

	Square(int x, int y, int wd){
		this.x = x; this.y = y; this.wd = wd;
	}
}

class SquareAreaCalculator{
	int calculate(int wd){return wd * wd;}
}
\end{lstlisting}

In Java, detecting this behaviour involves searching for patterns where an object contains method which does very little work besides forwarding the call to a method on another object. This is the simplest form of transferring responsibility to another class and should be independent from any state held by the forwardee. This is because needs to be able respond correctly to requests from other forwarders without influence from state set in previous requests.
\newline

If the receiver of a forwarded request were to hold state about an object delegating to it then it would likely run into issues if other objects also forward requests to it. Likewise, if the system were re-implemented with a stateful forwarding recipient in a language which supports forwarding as object inheritance then it would run into the same problems when sharing it between parents.

\section{Delegation}
Delegation is often described as forwarding \java{this.f(...)} calls to \java{other.f(...)} \textbf{on behalf of this.} That is, dispatch the call to \java{other.f(...)} but have the self reference within that call point back to my self reference.
\newline

In this example, the \java{Square} object is delegating responsibility for area calculation to the \java{SquareAreaCalcuator}. The \java{SquareAreaCalculator} contains a final field to point to the self reference of a single \java{Square} object which indicates that the \java{SquareAreaCalculator} belongs to one instance of \java{Square} and always will. In an object delegation model the public final field could be removed, instead opting to have the self reference of the \java{SquareAreaCalculator} set to the self reference of the \java{Square} object.
\begin{lstlisting}
class Square{
	int x, y, wd;
	SquareAreaCalculator areaCalculator = new SquareAreaCalculator(this);

	int area(){return areaCalculator.calculate();}

	Square(int x, int y, int wd){
		this.x = x; this.y = y; this.wd = wd;
	}
}

class SquareAreaCalculator{
	private final Square square;

	SquareAreaCalculator(Square square){this.square = square;}

	int calculate(){return square.wd * square.wd;}
}
\end{lstlisting}

Examples in Java which would be well suited to a language with native support for delegation are those where the code is effectively forwarding to an object which accepts \java{this} as either a constructor parameter or as a parameter to many of its public methods. This indicates that the object being called to is designed to do a lot of work which is dependent on the \java{this} reference of another object being passed in. By using a language which supports delegation natively, it would be possible to change the self reference of the delegatee to instead be the self reference of the delegator, removing the need to pass it as a parameter.

\section{Uniform Identity}
Under Uniform Identity, objects are constructed by first going up the object hierarchy setting up fields, then going back down the hierarchy calling initialiser functions. This maintains a single object identity throughout construction of the object.
\newline

In this example, the \java{Square} class inherits from another class which knows how to calculate the area of a more general figure so can also be used to offer the same functionality to the \java{Square}. 
\begin{lstlisting}
class Rectangle{
	int x, y, wd, ht;

	int area(){return wd * ht;}

	Rectangle(int x, int y, int wd, int ht){
		this.x = x; this.y = y; this.wd = wd; this.ht = ht;
	}
}

class Square extends Rectangle{
	Square(int x, int y, int wd){super(x, y, wd, wd);}
}
\end{lstlisting}

All examples of classical inheritance in Java follow the Uniform Identity construction model. Therefore, to find examples supporting the need for Uniform Identity, we must simply look for typical uses of inheritance in Java where a subclass makes some use of functionality from the parent class. Uniform Identity is the object inheritance model underlying Java's class inheritance structure, but others can also model the behaviour fairly closely. For example, Merged Identity closely matches the C++ model of class inheritance and, with a few exceptions, most examples of Java class based inheritance could also function in a Merged Identity model. Uniform Identity is the implementation Java's class based inheritance model encourages so it is expected to be the most common across corpus data. Because of this, any substantial use of forwarding or delegation would indicate that developers are intentionally dismissing Java's in-built language features as they believe it is possible to produce better code with other patterns.